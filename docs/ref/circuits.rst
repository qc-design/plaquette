.. Copyright 2023, It'sQ GmbH and the plaquette contributors
   SPDX-License-Identifier: Apache-2.0

.. _circuits-ref:

Circuits and gates in ``plaquette``
===================================

This page provides detailed explanations of all the gates and other instructions
supported in circuit simulations.

Background on Clifford circuits and stabilizer states
-----------------------------------------------------

Simulated states and circuits in plaquette are restricted to stabilizer states and
Clifford circuits because they can be simulated efficiently. Here, *efficient*
means that the necessary computation time scales polynomially with the number of
qubits involved. In a general simulation, the necessary computation time scales
exponentially instead of polynomially with the number of qubits.

A Clifford circuit is defined by the property that it always maps a tensor product of
Pauli operators to a tensor product of Pauli operators, and never to a more general
operator. If we refer to "stabilizer states", we actually mean states whose stabilizer
is a subset of the Pauli group. In other words, all the stabilizer generators are
tensor products of Pauli operators. As a consequence, a Clifford circuit maps
stabilizer states to stabilizer states and this is one of the key properties which
enables efficient simulation.

Clifford circuits are generated by the Hadamard, S and CNOT gates and they also include
all tensor products of Pauli operators. For more information, refer e.g. to
:cite:`nielsen_quantum_2010`.

.. todo::

    Nielsen&Chuang is helpful, but does not contain a definition of
    "Clifford circuit". Another reference would be better.


Clifford circuits in plaquette
------------------------------

In plaquette, circuits are defined using unitary gates as well as more general
instructions. For
simplicity, we refer to non-unitary instructions as "gates" as well. Gates
include well-known unitary gates like Pauli X, Y and Z, Hadamard, CX and CZ.
Special instructions for measuring and resetting qubits are among the set of supported
gates as well.

Error mechanisms acting on quantum systems are generally described as quantum channels
(i.e. CPTP maps). Quantum channels are non-Clifford operations and therefore, they
cannot be integrated directly into the simulation. Suppose that a quantum channel
is a probabilistic combination of unitary Clifford gates. In this case, we simulate
the channel by probabilistically applying one of the unitary gates.

.. todo::

    It would be nice to make the above paragraph more formal. This would include a
    formal discussion of the exact circumstances under which this procedure works well.

In summary, unitary and measurement gates are used to define a circuit which
implements an ideal measurement of many stabilizer generators without any errors.
Probabilistic gates are then used to add correlated and uncorrelated errors to the
simulation.


Defining circuits
-----------------

Circuits can be defined from strings:

>>> from plaquette import circuit
>>> circ = circuit.Circuit.from_str("X 0\nY 2 3")
>>> print(circ)
X 0
Y 2 3

It is also possible to append gates defined in a string:

>>> circ.append_from_str("Z 5 6\nR 0 1")
>>> print(circ)
X 0
Y 2 3
Z 5 6
R 0 1

Circuits can be built programmatically using `.circuit.CircuitBuilder`:

>>> circ = circuit.Circuit()
>>> c = circuit.CircuitBuilder(circ)
>>> c.X(0)
>>> c.Y(2, 3)
>>> print(circ)
X 0
Y 2 3

In other cases, it can be more convenient to use
:meth:`~plaquette.circuit.Circuit.append` directly:

>>> circ.append("Z", 5, 6)
>>> print(circ)
X 0
Y 2 3
Z 5 6

More examples can be found in the :ref:`circuits-guide`.


Overview of supported gates
---------------------------

:ref:`gates-unitary-singlequbit`:

.. list-table::
    :width: 100%
    :widths: 5 20

    * - ``X``
      - :ref:`Gate X`
    * - ``Y``
      - :ref:`Gate Y`
    * - ``Z``
      - :ref:`Gate Z`
    * - ``H``
      - :ref:`Gate H`

:ref:`gates-unitary-twoqubit`:

.. list-table::
    :width: 100%
    :widths: 5 20

    * - ``CX``
      - :ref:`Gate CX`

    * - ``CZ``
      - :ref:`Gate CZ`

:ref:`gates-measurement-reset`:

.. list-table::
    :width: 100%
    :widths: 5 20

    * - ``M``
      - :ref:`Gate M`
    * - ``R``
      - :ref:`Gate R`

:ref:`gates-probabilistic`:

.. list-table::
    :width: 100%
    :widths: 5 20

    * - ``E_PAULI``
      - :ref:`Gate E_PAULI`
    * - ``E_PAULI2``
      - :ref:`Gate E_PAULI2`
    * - ``E_ERASE``
      - :ref:`Gate E_ERASE`
    * - ``DEPOLARIZE``
      - :ref:`Gate DEPOLARIZE`
    * - ``ERROR``
      - :ref:`Gate ERROR`
    * - ``ERROR_CONTINUE``
      - :ref:`Gate ERROR_CONTINUE`
    * - ``ERROR_ELSE``
      - :ref:`Gate ERROR_ELSE`


.. _gates-unitary-singlequbit:

Single-qubit unitary gates
--------------------------

.. _Gate X:

Pauli X gate
^^^^^^^^^^^^

.. code::

    X 0

Applies Pauli X on qubit 0.

.. code::

    X 0 1 2

Applies Pauli X on qubits 0, 1 and 2.


.. _Gate Y:

Pauli Y gate
^^^^^^^^^^^^

.. code::

    Y 3 4 5

Applies Pauli Y on qubits 3, 4, 5.


.. _Gate Z:

Pauli Z gate
^^^^^^^^^^^^

.. code::

    Z 0 1 2

Applies Pauli Z on qubits 0, 1 and 2.


.. _Gate H:

Hadamard gate
^^^^^^^^^^^^^

.. code::

    H 0 1 2

Applies the Hadamard gate on qubits 0, 1 and 2.


.. _gates-unitary-twoqubit:

Two-qubit unitary gates
-----------------------

.. _Gate CX:

Controlled-X gate (aka controlled-not gate)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code::

    CX 1 2 11 12

* Applies CX on (1, 2) and (11, 12).
* 1 and 11 are control qubits.
* 2 and 12 are target qubits.


.. _Gate CZ:

Controlled-Z gate (aka controlled-phase gate)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code::

    CZ 1 2 11 12

* Applies CZ on (1, 2) and (11, 12).


.. _gates-measurement-reset:

Measurement and reset gates
---------------------------

.. _Gate M:

Measure qubits in Z basis
^^^^^^^^^^^^^^^^^^^^^^^^^

.. code::

    M 0 1 2

* Measure qubits 0, 1 and 2 independently in the Z basis.
* Three separate results are appended to the list of measurement results.

.. _Gate R:

Reset qubits to +Z eigenstate
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code::

    R 0 1 2

Independently reset qubits 0, 1 and 2 to the +1 eigenstate of Z on each qubit.


.. _gates-probabilistic:

Probabilistic quantum channels
------------------------------

.. _Gate E_PAULI:

Probabilistic Pauli channel
^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code::

    E_PAULI 0.01 0.02 0.03 7

* Acts on qubit 7.
* Applies Pauli X with probability 0.01.
* Applies Pauli Y with probability 0.02.
* Applies Pauli Z with probability 0.03.
* Applies identity with probability 0.94.

.. _Gate E_PAULI2:

Two-qubit probabilistic Pauli Channel
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code::

   E_PAULI2 0.001 0.002 ... 0.014 0.015 7 8

* Acts on qubits 7 and 8.
* Probabilities are ordered IX IY IZ XI XX ... ZY ZZ.
* 0.001 is the probability for IX.
* 0.002 is the probability for IY.
* ...
* 0.014 is the probability for ZY.
* 0.015 is the probability for ZZ.

.. _Gate E_ERASE:

Probabilistic erasure channel
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code::

   E_ERASE 0.01 3

* Applies an erasure channel on qubit 3 with probability 0.01.
* Appends one value to the list of erasure information (True or False, in case the
  erasure channel was applied / was not applied).
* If the erasure channel is applied, one of I, X, Y or Z is applied on qubit 3
  with 25% probability each.

.. _Gate DEPOLARIZE:

Probabilistic depolarization channel
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code::

   DEPOLARIZE 0 1 2

* Applies a separate probabilistic depolarization channel on each of the qubits
  0, 1 and 2.
* Applies X, Y or Z with 33% probability on each qubit.


.. _Gate ERROR:

Apply another gate probabilistically
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code::

    ERROR          0.01 X 1

Applies the gate ``X 1`` with a probability of 0.01.


.. note::

    .. code::

        ERROR 0.1 X 0 1 2

    will apply ``X`` on all three qubits (10%) or on no qubit at all (90%).

    If you want independent errors on the three qubits, you have to use one error
    instruction per qubit:

    .. code::

        ERROR 0.1 X 0
        ERROR 0.1 X 1
        ERROR 0.1 X 2


.. _Gate ERROR_CONTINUE:

Apply a gate sequence probabilistically
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code::

    ERROR           0.01 X 1
    ERROR_CONTINUE       Z 2

Applies the gates ``X 1`` and ``Z 2`` with a probability of 0.01.

.. _Gate ERROR_ELSE:

Apply one of several gates probabilistically
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code::

    ERROR       0.01 X 1
    ERROR_ELSE  0.02 X 2

* With a probability of 0.01, the gate ``X 1`` is applied.
* If ``X 1`` was not applied, the gate ``X 2`` is applied with a probability of 0.02.

.. code::

    ERROR           0.01 X 1
    ERROR_CONTINUE       Z 11

    ERROR_ELSE      0.02 X 2
    ERROR_CONTINUE       Z 22

* With a probability of 0.01, the gates ``X 1`` and ``Z 11`` are applied.
* If the two gates were not applied, the gates ``X 2`` and ``Z 22`` are applied.

