.. Copyright 2023, QC Design GmbH and the plaquette contributors
   SPDX-License-Identifier: Apache-2.0

.. _errors-guide:

Specifying errors in ``plaquette``
==================================

.. sectionauthor:: Varun Seshadri

``plaquette`` supports various fine-grained controls to tune the error model
used by the simulators. This guide shows use how to set error using
:class:`~plaquette.errors.ErrorData` and how it interfaces with the
rest of the code.

First things, what does the :class:`~plaquette.errors.ErrorData` object
contain? Internally, this class holds

- a dataframe storing the error specification for the qubit
  errors.
- a dataframe storing the error specification for the gate errors.
- a list storing which qubit errors to apply, useful for the case when you more
  have more data, but only want to simulate a subset of it.
- a list storing which gate errors to apply, useful for the case when you
  have more gates than you want to simulate.

The errors that can be specified are broadly split into two
categories: *qubit errors* and *gate errors*. The idea is that qubit errors
encapsulate the fragility of the qubit by itself and gate errors
encapsulate the fragility of the quantum gates applied. The possible
qubit errors currently are Pauli X, Y and Z, erasures and measurement
errors. Each gate error can induce a subset of errors from the mapping
below

.. list-table:: Possible induced channels
   :header-rows: 1

   * - Gate
     - Induced Channels
   * - :math:`H, R, M`
     - :math:`X, Y, Z`
   * - :math:`CX, CZ`
     - :math:`\{I,X,Y,Z\} \times \{I,X,Y,Z\}`

Conceptually, *fabrication errors* may not directly fit into these two
categories. However, for practical purpose, faulty qubits are added to the
qubit error set and faulty gates are added to the gate error set.

The ``ErrorData`` class
-----------------------

The most important methods and attributes you need to care about the
:class:`.ErrorData` class are listed below:

- :meth:`~plaquette.errors.ErrorData.from_lattice()`
- :meth:`~plaquette.errors.ErrorData.from_csv()`
- :meth:`~plaquette.errors.ErrorData.update()`
- :meth:`~plaquette.errors.ErrorData.update_from_csv()`
- :meth:`~plaquette.errors.ErrorData.add_qubit_error()`
- :meth:`~plaquette.errors.ErrorData.update_qubit_error()`
- :meth:`~plaquette.errors.ErrorData.add_gate_error()`
- :meth:`~plaquette.errors.ErrorData.save_to_csv()`
- :attr:`~plaquette.errors.ErrorData.qubit_errors_dict`
- :attr:`~plaquette.errors.ErrorData.gate_errors_dict`
- :attr:`~plaquette.errors.ErrorData.error_data_dict`

An :class:`.ErrorData` can be initiated using :meth:`.ErrorData.from_lattice`.
It takes as arguments a :class:`.QubitErrorsConfig` and
:class:`.GateErrorsConfig`. If both of these are none, it defaults to an error
model with depolarising noise probability of 0.1 on the data-qubits. Below you
can see the error value table generated by the above code-block.

>>> from plaquette import errors
>>> from plaquette.codes import LatticeCode
>>> code = LatticeCode.make_rotated_planar(size=3, n_rounds=1)
>>> ed = errors.ErrorData().from_lattice(code.lattice)
>>> ed  # doctest: +ELLIPSIS
ErrorData(qubit_errors=          qubit_id qubit_type    X    Y    Z
qubit_id                                    ...

Below you can see the error value table generated by the above code-block.

.. table:: Default Qubit Errors Table

   ========  ==========  ===  ===  ===
   qubit_id  qubit_type   X    Y    Z
   ========  ==========  ===  ===  ===
          0  data        0.1  0.1  0.1
          1  data        0.1  0.1  0.1
          2  data        0.1  0.1  0.1
          3  data        0.1  0.1  0.1
          4  data        0.1  0.1  0.1
          5  data        0.1  0.1  0.1
          6  data        0.1  0.1  0.1
          7  data        0.1  0.1  0.1
          8  data        0.1  0.1  0.1
          9  ancilla     0.1  0.1  0.1
         10  ancilla     0.1  0.1  0.1
         11  ancilla     0.1  0.1  0.1
         12  ancilla     0.1  0.1  0.1
         13  ancilla     0.1  0.1  0.1
         14  ancilla     0.1  0.1  0.1
         15  ancilla     0.1  0.1  0.1
         16  ancilla     0.1  0.1  0.1
   ========  ==========  ===  ===  ===

Use :meth:`~plaquette.errors.ErrorData.add_qubit_error` to add a qubit
error to the dataframe, if the error column does not exist . If it already exists, use
:meth:`~plaquette.errors.ErrorData.update_qubit_error`. The valid values for
``error_name`` are ``X``, ``Y``, ``Z``, ``erasure``, ``measurement``, or
``fabrication``.

>>> data_list =  [qubit.equbit_idx for qubit in code.lattice.dataqubits]
>>> ancilla_list = [qubit.equbit_idx for qubit in code.lattice.stabgens]
>>> ed.add_qubit_error(
...     qubit_id=data_list,
...     error_name="erasure",
...     probs=errors.generate_constant_errors(0.1, data_list)
... )
>>> ed.add_qubit_error(
...     qubit_id=ancilla_list,
...     error_name="measurement",
...     probs=errors.generate_gaussian_errors(0.1, 0.02, ancilla_list)
... )
>>> ed
ErrorData(qubit_errors=          qubit_id qubit_type    X    Y    Z  erasure  measurement
qubit_id                                                          ...

The updated table looks like the one below.

.. table:: Qubit errors dataframe after adding erasure and measurement errors.

    ========  ==========  ===  ===  ===  =======  ===================
    qubit_id  qubit_type   X    Y    Z   erasure      measurement
    ========  ==========  ===  ===  ===  =======  ===================
           0  data        0.1  0.1  0.1      0.1  0.00000000000000000
           1  data        0.1  0.1  0.1      0.1  0.00000000000000000
           2  data        0.1  0.1  0.1      0.1  0.00000000000000000
           3  data        0.1  0.1  0.1      0.1  0.00000000000000000
           4  data        0.1  0.1  0.1      0.1  0.00000000000000000
           5  data        0.1  0.1  0.1      0.1  0.00000000000000000
           6  data        0.1  0.1  0.1      0.1  0.00000000000000000
           7  data        0.1  0.1  0.1      0.1  0.00000000000000000
           8  data        0.1  0.1  0.1      0.1  0.00000000000000000
           9  ancilla     0.1  0.1  0.1      0.0  0.07483464266648852
          10  ancilla     0.1  0.1  0.1      0.0  0.09408755341754801
          11  ancilla     0.1  0.1  0.1      0.0  0.12196524551182718
          12  ancilla     0.1  0.1  0.1      0.0  0.06893983033842802
          13  ancilla     0.1  0.1  0.1      0.0  0.15678936654490977
          14  ancilla     0.1  0.1  0.1      0.0  0.10825359126265179
          15  ancilla     0.1  0.1  0.1      0.0  0.11660360069059533
          16  ancilla     0.1  0.1  0.1      0.0  0.09176437904865854
    ========  ==========  ===  ===  ===  =======  ===================

A qubit error value already present in the dataframe can be updated using the
:meth:`~plaquette.errors.ErrorData.update_qubit_error()` method.
For example, we can set the measurement failure probability for qubit 9 to 0
by calling ``ed.update_qubit_error(9, "measurement", 0.0)``.
Analogous functions for adding
(:meth:`~plaquette.errors.ErrorData.add_gate_error()`) and updating
(:meth:`~plaquette.errors.ErrorData.update_gate_error()` gate errors also
available.

Storing errors in supplementary files
-------------------------------------

Since ``plaquette`` allows you to specify errors on a *per qubit* basis, it
might become cumbersome to set them all in code. The same level of control
can be achieved with simple CSV files which store the error information in
a specified format.

Suppose the user already has a CSV containing qubit errors, you can update
and existing :class:`.ErrorData` object via two methods:
:meth:`.ErrorData.update_from_csv` or :meth:`.ErrorData.from_csv`.

Using the first method with ``overwrite=True`` implies that dataframe
will only contain data from the CSV file. Otherwise, overlapping
values in columns already present will be updated, while the columns that are
in the CSV but not in the dataframe will be appended to dataframe. The
useful case where :meth:`.ErrorData.update_from_csv` can be used is to add
gate errors from a CSV file when the qubit errors are already present

>>> ed.update_from_csv(gate_error_csv="docs/advanced/errors/gate_errors.csv")

where ``gate_errors.csv`` is :download:`something like this <gate_errors.csv>`.

The function :meth:`~plaquette.errors.ErrorData.update()` works in similar
fashion. The difference is that :meth:`~.ErrorData.update_from_csv()`
takes the CSV paths as the arguments. The function :meth:`~.ErrorData.update()`
takes the dataframes as the argument.


The updated table of gate errors is shown below, which reflect the values of the
CSV file.

.. table:: Gate Errors Dataframe after update from CSV

    ====  ================  ===============  ================
    gate     on_qubits      induced_errors        probs
    ====  ================  ===============  ================
    CZ    [13, 1]           ['XI', 'ZZ']     [0.1, 0.1]
    H     [13, 14, 15, 16]  ['X', 'Y', 'Z']  [0.1, 0.2, 0.01]
    CZ    [13, 2]           ['ZI', 'XX']     [0.1, 0.2]
    CZ    [13, 1]           ['YY']           [0.1]
    ====  ================  ===============  ================

The validity of the given error specification can always be validated
using the following function :meth:`plaquette.errors.ErrorData.check_against_code()`. If
not valid, it throws an error, else nothing is returned.

>>> ed.check_against_code(code)

The other arguments of :meth:`~plaquette.errors.ErrorData.from_lattice`,
namely,`qubit_error_config, gate_error_config` are structured in a particular
way. These arguments are usually got as output from
:attr:`~plaquette.frontend.QubitErrorsConfig.simulated_errors` and
:attr:`~plaquette.frontend.GateErrorsConfig.simulated_errors`. See the
:ref:`tutorial on frontend <declarative-guide>` to see how they work.

A point to note is that the user can choose which qubit errors and gate
errors to simulate by directly setting, ``ed.enabled_qubit_errors`` and
``ed.enabled_gate_errors``.

>>> ed.update_from_csv(qubit_error_csv="docs/advanced/errors/spem.csv", overwrite=False)

The qubit errors table after the update.

.. table:: Qubit errors dataframe after update from `csv`.

    ========  ==========  ====  ====  ====  =======  ===========
    qubit_id  qubit_type   X     Y     Z    erasure  measurement
    ========  ==========  ====  ====  ====  =======  ===========
           0  data        0.01  0.01  0.02    0.003        0.030
           1  data        0.01  0.01  0.02    0.003        0.030
           2  data        0.01  0.01  0.02    0.003        0.030
           3  data        0.01  0.01  0.02    0.003        0.030
           4  data        0.01  0.01  0.02    0.003        0.030
           5  data        0.01  0.01  0.02    0.003        0.030
           6  data        0.01  0.01  0.02    0.003        0.030
           7  data        0.01  0.01  0.02    0.003        0.030
           8  data        0.01  0.01  0.02    0.003        0.030
           9  ancilla     0.02  0.02  0.02    0.020        0.001
          10  ancilla     0.02  0.02  0.02    0.020        0.001
          11  ancilla     0.02  0.02  0.02    0.020        0.001
          12  ancilla     0.02  0.02  0.02    0.020        0.001
          13  ancilla     0.02  0.02  0.02    0.020        0.001
          14  ancilla     0.02  0.02  0.02    0.020        0.001
          15  ancilla     0.02  0.02  0.02    0.020        0.001
          16  ancilla     0.02  0.02  0.02    0.020        0.001
    ========  ==========  ====  ====  ====  =======  ===========

The gate errors dataframe remains the same as it is not changed.

Handling the data about errors in ``plaquette`` for the user is done through
:mod:`pandas` dataframes for ease of use. On the other hand, the internally in
other modules, it uses defined one of these pre-defined ``TypedDict``
dictionaries. See the api docs for :mod:`~plaquette.errors` for detailed
information. The :class:`.ErrorData` class has three properties the output the required
dictionaries for use later in the code base, namely:

1. :attr:`~plaquette.errors.ErrorData.qubit_errors_dict` - Gives a
   dictionary of qubit errors of type :class:`~plaquette.errors.QubitErrorsDict`.
   For example of usage of this dictionary, see
   :meth:`~plaquette.circuit.generator.generate_qec_circuit`.
2. :attr:`~plaquette.errors.ErrorData.gate_errors_dict` - Gives a dictionary
   of gate errors of type :class:`~plaquette.errors.GateErrorsDict`. For example
   of usage of this dictionary, see
   :meth:`~plaquette.circuit.generator.generate_qec_circuit`.
3. :attr:`~plaquette.errors.ErrorData.error_data_dict` - Gives a union of
   the aforementioned dictionaries of type
   :class:`~plaquette.errors.ErrorDataDict`. For example of
   usage, see :meth:`~plaquette.decoders.decoderbase.DecoderInterface.from_code` in
   decoders module.

For example, the :attr:`.ErrorData.error_data_dict` property in the example we
have constructed is

>>> ed.error_data_dict
{'CZ': {(13, 1): {'yy': 0.1}, (13, 2): {'zi': 0.1, 'xx': 0.2}}, ...}
